Index: WS.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import asyncio, json, websockets\r\nfrom threading import Thread\r\n\r\n\r\nclass WebSocket:\r\n    def __init__(self, websocket, init_info):\r\n        self.init_info = init_info\r\n        self.websocket = websocket\r\n\r\n    def send_msg(self, msgText):\r\n        asyncio.create_task(_send_msg_as(msgText, self.websocket))\r\n\r\n\r\nasync def _send_msg_as(msg, websocket):\r\n    await websocket.send(msg)\r\n\r\n\r\nasync def _main(websocket):\r\n    print(\"Client connected\")\r\n    client = await websocket.recv()\r\n    client = WebSocket(websocket, json.loads(client))\r\n    connected_clients.append(client)\r\n    while True:\r\n        msg = await websocket.recv()\r\n        new_msg_func(msg, client)\r\n\r\n\r\ndef new_msg(msg, client):\r\n    print(f\"сообщение от {client.init_info['username']}: {msg}\")\r\n    client.send_msg(\"ответ\")\r\n\r\n\r\ndef run():\r\n    asyncio.set_event_loop(asyncio.new_event_loop())\r\n    start_server = websockets.serve(_main, \"localhost\", 5000)\r\n    asyncio.get_event_loop().run_until_complete(start_server)\r\n    asyncio.get_event_loop().run_forever()\r\n\r\n\r\nconnected_clients = []\r\nnew_msg_func = new_msg\r\nThread(target=run).start()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/WS.py b/WS.py
--- a/WS.py	(revision 68fceef83552e450cd810ff8d7fd5b0e3c5d5a68)
+++ b/WS.py	(date 1711221545111)
@@ -1,11 +1,14 @@
 import asyncio, json, websockets
 from threading import Thread
+from data_py import db_session
+from data_py.users import User
 
 
 class WebSocket:
-    def __init__(self, websocket, init_info):
+    def init(self, websocket, init_info):
         self.init_info = init_info
         self.websocket = websocket
+        self.honest = check_hones_func(self.init_info)
 
     def send_msg(self, msgText):
         asyncio.create_task(_send_msg_as(msgText, self.websocket))
@@ -37,6 +40,16 @@
     asyncio.get_event_loop().run_forever()
 
 
+def check_hones_func(user_info: dict):
+    db_session.global_init('db/messenger.db')
+    db_sess = db_session.create_session()
+    user = db_sess.query(User).filter(User.username == user_info['username']).first()
+    if user is not None:
+        if user.hashed_password == user_info['password_hash']:
+            return True
+    return False
+
+
 connected_clients = []
 new_msg_func = new_msg
 Thread(target=run).start()
Index: server.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\n\r\nfrom flask import Flask, request, send_from_directory, jsonify\r\nfrom werkzeug.security import generate_password_hash\r\n\r\nfrom data_py import db_session\r\nfrom data_py.messages import Message\r\nfrom data_py.users import User\r\nfrom data_py.chats import Chat\r\n\r\napp = Flask(__name__)\r\n\r\nUSERS_REGISTERING_NOW = {}\r\n\r\n\r\n@app.route('/login')\r\ndef login_page():\r\n    with open(\"front/login/index.html\") as f:\r\n        return f.read()\r\n\r\n\r\n@app.route('/registration')\r\ndef registration_page():\r\n    with open(\"front/registration/index.html\") as f:\r\n        return f.read()\r\n\r\n\r\n@app.route('/')\r\ndef main_page():\r\n    with open(\"front/main/index.html\") as f:\r\n        return f.read()\r\n\r\n\r\n@app.route('/request/<path:path>')\r\ndef check_registration(path):  # эта функция для обработки запросов от js'а\r\n    print(f'request from \"{path}\"')\r\n    print(f'arguments: {request.args}')\r\n    if path == \"registration/check_email\":  # ->->->\r\n        a_email = request.args.get(\"email\")\r\n        db_sess = db_session.create_session()\r\n        email_is_free = not db_sess.query(User).filter(\r\n            User.email == a_email).first()  # email свободен?\r\n        print(\"email is free: \" + email_is_free)\r\n        return jsonify(email_is_free)  # <-<-<-\r\n\r\n    if path == \"registration/check_username\":  # ->->->\r\n        a_username = request.args.get(\"username\")\r\n        db_sess = db_session.create_session()\r\n        username_is_free = not db_sess.query(User).filter(\r\n            User.username == a_username).first()  # username свободен?\r\n        print(\"username is free: \" + username_is_free)\r\n        return jsonify(username_is_free)  # <-<-<-\r\n\r\n    if path == \"registration/send_email\":  # пользователь запрашивает код подтверждения\r\n        a_email = request.args.get(\"email\")\r\n        a_username = request.args.get(\"username\")\r\n        # тут надо ещё раз проверить, что всё ок (нет пользователей с такой почтой и username),\r\n        db_sess = db_session.create_session()\r\n        is_ok = not db_sess.query(User).filter(\r\n            User.username == a_username).first() and not db_sess.query(\r\n            User).filter(\r\n            User.email == a_email).first() and \"@\" not in a_username  # всё ок?\r\n        print(is_ok)\r\n        if is_ok:\r\n            code = random.randint(100000, 999999)  # код подтверждения\r\n            # отправить письмо по почте с кодом подтверждения.\r\n            # пока не отправляем, а просто выводим в консоль\r\n            print(f\"{a_email}: код подтверждения отпрален на почту ({code})\")\r\n            USERS_REGISTERING_NOW[a_email] = (code, a_username)\r\n        return {\"response\": is_ok}\r\n\r\n    if path == \"registration/check_code\":  # от пользователя получены данные для регистрации\r\n        a_email = request.args.get(\"email\")\r\n        a_code = request.args.get(\"code\")\r\n\r\n        # тут надо проверить, что код верный,\r\n        is_success = False  # всё ок?\r\n        hashed_pass = None\r\n        if a_email in USERS_REGISTERING_NOW:\r\n            is_success = int(USERS_REGISTERING_NOW[a_email][0]) == int(a_code)\r\n            print(\"code is valid - \" + str(is_success))\r\n            if is_success:\r\n                a_username = USERS_REGISTERING_NOW[a_email][1]\r\n                del USERS_REGISTERING_NOW[a_email]\r\n                a_name = request.args.get(\"name\")\r\n                a_password = request.args.get(\"password\")\r\n                # если код верный, то внести пользовотеля в БД\r\n                db_sess = db_session.create_session()\r\n                user = User(name=a_name,\r\n                            username=a_username,\r\n                            email=a_email)\r\n                user.set_password(a_password)\r\n                hashed_pass = user.hashed_password\r\n                db_sess.add(user)\r\n                db_sess.commit()\r\n                print('user register')\r\n        return {\"response\": is_success, 'hash': hashed_pass}\r\n\r\n    if path == \"login\":  # от пользователя получены данные для входа\r\n        a_email_username = request.args.get(\"email-username\")\r\n        a_password = request.args.get(\"password\")\r\n        db_sess = db_session.create_session()\r\n        user = db_sess.query(User).filter(\r\n            a_email_username == User.email).first()\r\n        if user is None:\r\n            user = db_sess.query(User).filter(\r\n                a_email_username == User.username).first()\r\n        is_ok = user and user.check_password(a_password)\r\n        if is_ok is None:\r\n            is_ok = False\r\n            hashed_pass, username, name, email = None, None, None, None\r\n        else:\r\n            hashed_pass = user.hashed_password\r\n            name, email, username = user.name, user.email, user.username\r\n        print(is_ok)\r\n        return {\"response\": is_ok, 'hash': hashed_pass, 'username': username,\r\n                'name': name, 'email': email}\r\n    if path == \"start_chat\":\r\n        pass_hash = request.args.get(\"password_hash\")\r\n        db_sess = db_session.create_session()\r\n        fst_user = db_sess.query(User).filter(\r\n            User.username == request.args.get(\"my_username\")).first()\r\n        scnd_user = db_sess.query(User).filter(\r\n            User.username == request.args.get(\"another_username\")).first()\r\n        if not fst_user.check_password(pass_hash):\r\n            return {\"response\": False, 'error': 'Hash does not match'}\r\n            chat = Chat(users=f'{fst_user.id};{scnd_user.id}',\r\n                        type='single')\r\n        db_sess.add(chat)\r\n        db_sess.commit()\r\n        fst_user.add_chat(chat.id)\r\n        scnd_user.add_chat(chat.id)\r\n        print(f'added chat: {chat.id}')\r\n        return\r\n    if path == 'get_my_chats':  # {\"chat_name\", \"chat_type\", \"chat_last_message\", \"number_of_unread_messages\"}\r\n        pass_hash = request.args.get(\"password_hash\")\r\n        db_sess = db_session.create_session()\r\n\r\n        user = db_sess.query(User).filter(\r\n            User.username == request.args.get('username')).first()\r\n        if not user.check_password(pass_hash):\r\n            return {\"response\": False, 'error': 'Hash does not match'}\r\n        user_chats_id = user.chats.split(';')\r\n        answer = []\r\n        for chat_id in user_chats_id:\r\n            chat = db_sess.query(Chat).filter(Chat.id == chat_id).first()\r\n            last_mess = \\\r\n                sorted(chat.messages, key=lambda x: x.id, reverse=True)[0]\r\n            answer.append({'chat_id': chat.id,\r\n                           \"chat_name\": chat.users,\r\n                           \"chat_type\": chat.type,\r\n                           \"number_of_unread_messages\": chat.unread_messages,\r\n                           \"chat_last_message\": {\r\n                               \"message_text\": last_mess.text,\r\n                               \"message_sender\": last_mess.sender,\r\n                               \"message_date\": last_mess.date}})\r\n        return answer\r\n    return {\"response\": False}\r\n\r\n\r\n@app.route('/front/<path:filename>')\r\ndef get_file_in_front(filename):\r\n    if True:\r\n        print(request.remote_addr + \" запросил \" + filename)\r\n        return send_from_directory('front', filename)\r\n    else:\r\n        print(request.remote_addr + \" запросил \" + filename + \" - ОТКАЗАНО!\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    db_session.global_init('db/messenger.db')\r\n    print(\"окно регистрации тут - http://127.0.0.1:8080/registration\")\r\n    print(\"окно входа тут - http://127.0.0.1:8080/login\")\r\n    app.run(port=8080, host='127.0.0.1')\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/server.py b/server.py
--- a/server.py	(revision 68fceef83552e450cd810ff8d7fd5b0e3c5d5a68)
+++ b/server.py	(date 1711222892185)
@@ -2,7 +2,7 @@
 
 from flask import Flask, request, send_from_directory, jsonify
 from werkzeug.security import generate_password_hash
-
+import WS
 from data_py import db_session
 from data_py.messages import Message
 from data_py.users import User
@@ -122,10 +122,9 @@
             User.username == request.args.get("my_username")).first()
         scnd_user = db_sess.query(User).filter(
             User.username == request.args.get("another_username")).first()
-        if not fst_user.check_password(pass_hash):
-            return {"response": False, 'error': 'Hash does not match'}
-            chat = Chat(users=f'{fst_user.id};{scnd_user.id}',
-                        type='single')
+        check_password_hash(fst_user, pass_hash)
+        chat = Chat(users=f'{fst_user.id};{scnd_user.id}',
+                    type='single')
         db_sess.add(chat)
         db_sess.commit()
         fst_user.add_chat(chat.id)
@@ -138,8 +137,7 @@
 
         user = db_sess.query(User).filter(
             User.username == request.args.get('username')).first()
-        if not user.check_password(pass_hash):
-            return {"response": False, 'error': 'Hash does not match'}
+        check_password_hash(user, pass_hash)
         user_chats_id = user.chats.split(';')
         answer = []
         for chat_id in user_chats_id:
@@ -167,6 +165,10 @@
         print(request.remote_addr + " запросил " + filename + " - ОТКАЗАНО!")
 
 
+def check_password_hash(user, pass_hash):
+    if user.hashed_password != pass_hash:
+        return {"response": False, 'error': 'Hash does not match'}
+
 if __name__ == '__main__':
     db_session.global_init('db/messenger.db')
     print("окно регистрации тут - http://127.0.0.1:8080/registration")
